///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#include "RenderObject_Skybox.h"

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
RenderObject_Skybox::RenderObject_Skybox()
{
}

void RenderObject_Skybox::Draw(Shader* _shader)
{
	_shader->use();
	mesh->Draw(_shader);
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
RenderObject_Skybox::RenderObject_Skybox(const char* vertexPath, const char* fragmentPath, const char* outlineVertex, const char* outlineFrag)
	:RenderObject(vertexPath, fragmentPath, outlineVertex, outlineFrag)
{
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void RenderObject_Skybox::SetupRenderObject(const char* modelPath)
{
	mesh = unique_ptr<Mesh>(new Mesh(SIMPLE_MESH_TYPE::SKYBOX));
}

void RenderObject_Skybox::PreRender()
{
	//Pass in transformMetrix
	shader->use();
	unsigned int loc = glGetUniformLocation(shader->ID, "model");
	glUniformMatrix4fv(loc, 1, GL_FALSE, glm::value_ptr(ModelMetrix));

	//Pass in view matrix
	loc = glGetUniformLocation(shader->ID, "view");
	ViewMetrix = glm::mat4(glm::mat3(ViewMetrix)); // remove translation from the view matrix
	glUniformMatrix4fv(loc, 1, GL_FALSE, glm::value_ptr(ViewMetrix));

	//Pass in perspective matrix
	loc = glGetUniformLocation(shader->ID, "projection");
	glUniformMatrix4fv(loc, 1, GL_FALSE, glm::value_ptr(ProjectionMetrix));
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void RenderObject_Skybox::Destroy()
{
	shader.reset();
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void RenderObject_Skybox::Draw()
{
	glDepthFunc(GL_LEQUAL);  // change depth function so depth test passes when values are equal to depth buffer's content
	shader->use();
	mesh->Draw(shader.get());
	glDepthFunc(GL_LESS); // set depth function back to default
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void RenderObject_Skybox::DrawWithOutline()
{
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
RenderObject* RenderObjectFactory_Skybox::CreateRenderObject()
{
	RenderObject* object = new RenderObject_Skybox();
	object->SetupRenderObject();
	return object;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
RenderObject* RenderObjectFactory_Skybox::CreateRenderObject(const char* vertexPath, const char* fragmentPath)
{
	RenderObject* object = new RenderObject_Skybox(vertexPath, fragmentPath);
	object->SetupRenderObject();
	return object;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
RenderObject* RenderObjectFactory_Skybox::CreateRenderObject(const char* vertexPath, const char* fragmentPath, const char* outlinePath, const char* outlineFrag)
{
	RenderObject* object = new RenderObject_Skybox(vertexPath, fragmentPath, outlinePath, outlineFrag);
	object->SetupRenderObject();
	return object;
}
